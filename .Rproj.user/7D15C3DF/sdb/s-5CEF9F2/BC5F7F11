{
    "contents" : "#' Genetic algorithm for module identification on weighted network\n#' \n#' Using genetic algorithm (GA) to identify active modules on weighted network. \n#' The connectedness of resulted module is ensured by connected components \n#' finding of binary encoded set of genes. Rewritten from COSINE package.\n#' \n#' @param lambda weight parameter in the objective\n#' @param node_score A N-length vector storing the nodes\n#' @param edge_score A M-length vector storing the edges\n#' @param EdgeList A two-columns matrix with each row a pair of weighted edges\n#' @param num_iter Number of iterations in GA\n#' @param muCh Mutation rate in GA\n#' @param zToR Zero to one ratio\n#' @param minsize The minimal size of module\n#' \n#' @return a list containing module size, best score, module as a list of nodes \n#' and a list of GA functions.\n#' \n#' @references Ma, Haisu, et al. \"COSINE: COndition-SpecIfic sub-NEtwork \n#' identification using a global optimization method.\" \n#' Bioinformatics 27.9 (2011): 1290-1298.\n#' @references Dong Li et al. Memetic algorithm for finding active connected subnetworks \n#' in intracellular networks. 2016.\n#' \n#' @author Dong Li, \\email{dxl466@cs.bham.ac.uk}\n#' @keywords GA, module identification\n#' \n#' @examples\n#' library(COSINE)\n#' data(scaled_node_score)\n#' data(scaled_edge_score)\n#' data(PPI)\n#' GA_result <- GA_search_connected(lambda=0.5,scaled_node_score,\n#' scaled_edge_score,PPI,num_iter=100, muCh=0.05, zToR=10, minsize=50)\n#' ## visualized by igraph\n#' selected = c()\n#' for (i in 1:dim(PPI)[1]){\n#'     if (PPI[i,1] %in% GA_result2$Subnet || PPI[i,2] %in% GA_result2$Subnet)\n#'         selected = c(selected,i)\n#' }\n#' library(igraph)\n#' g <- graph.data.frame(PPI[selected,], directed=FALSE)\n#' V(g)$color <- \"blue\"\n#' V(g)$color[match(GA_result2$Subnet,V(g)$name)] <- \"red\"\n#' layout <- layout.reingold.tilford(g, circular=T)\n#' plot(g,layout=layout, vertex.size=5, vertex.label.cex=5,vertex.label.dist=0.5,edge.width=5)\n\n#' @export\n#' \nGA_search_connected <- function(lambda,node_score,edge_score,EdgeList,\n                                num_iter=1000, muCh=0.05, zToR=10, minsize=10){\n    \n    ## define the objective scoring function for condition specific subnetwork \n    all_genes<<-names(node_score)\n    \n    subset_extract<-function(sub){    \n        genes = all_genes[sub]\n        edges <- EdgeList[,1] %in% genes & EdgeList[,2] %in% genes\n        \n        g <- graph.data.frame(EdgeList[edges,], directed=FALSE)\n        comps <- decompose.graph(g)\n        \n        m<-sum(edges)\n        total_score<- -10000\n        if(m>0){\n            for (i in 1:length(length(comps))) {\n                subgenes = names(V(comps[[i]]))\n                subedges = EdgeList[,1] %in% subgenes & EdgeList[,2] %in% subgenes\n                node_score<-sum(node_score[match(subgenes,all_genes)])/sqrt(length(V(comps[[i]])))\n                edge_score <-sum(edge_score[subedges])/sqrt(length(subedges))\n                \n                max_score<- lambda*edge_score + (1-lambda)*node_score\n                \n                if (max_score > total_score){\n                    total_score = max_score\n                    targetgenes = subgenes\n                }\n                \n            }\n            \n        }\n        return (targetgenes)\n    }\n    \n    subset_score<-function(sub){    \n        genes<-all_genes[sub==1]\n        n<-length(genes)    \n        if(n<minsize){return(10000)}\n        else{\n            edges<- EdgeList[,1] %in% genes & EdgeList[,2] %in% genes\n            m<-sum(edges)\n            total_score<- -10000\n            if(m>2){\n                #print(m)\n                g <- graph.data.frame(EdgeList[edges,], directed=FALSE)\n                comps <- decompose.graph(g)\n                \n                for (i in 1:length(length(comps))) {\n                    subgenes = names(V(comps[[i]]))\n                    subedges = EdgeList[,1] %in% subgenes & EdgeList[,2] %in% subgenes\n                    node_score <-sum(node_score[match(subgenes,all_genes)])/sqrt(length(V(comps[[i]])))\n                    edge_score <-sum(edge_score[subedges])/sqrt(length(subedges))\n                    max_score <- lambda*edge_score + (1-lambda)*node_score\n                    \n                    #if (node_score > total_score)\n                    #  total_score = node_score\n                    if (max_score > total_score)\n                        total_score = max_score\n                }\n                \n            }\n            return (-total_score)\n        }\n    }\n    \n    monitor <- function(obj) {\n        minEval = min(obj$evaluations);\n        filter = obj$evaluations == minEval;\n        #   print(table(filter))\n        bestObjectCount = sum(rep(1, obj$popSize)[filter]);\n        if (bestObjectCount > 1) {\n            bestSolution = obj$population[filter,][1,];\n        } else {\n            bestSolution = obj$population[filter,];\n        }\n        \n        outputBest = paste(obj$iter, \" #selected=\", sum(bestSolution),\n                           \" Best (Score=\", -minEval, \"):\\n\", sep=\"\");\n        print(outputBest)\n    }\n    \n    \n    ##Start search\n    \n    gene_num <- length(node_score)\n    print(paste(\"Working on lambda=\",lambda)) \n    GA_result <- rbga.bin(size=gene_num,evalFunc=subset_score,iters=num_iter,mutationChance=muCh,monitorFunc=monitor,zeroToOneRatio=zToR)      \n    a <- which.min(GA_result$evaluations)\n    final <- GA_result$population[a,]\n    b <- which(final==1)\n    \n    optimal_subnet = subset_extract(b)\n    num_gene_selected <- length(optimal_subnet)\n    \n    best_score <- (-1)*min(GA_result$evaluations)\n    print(paste(\"Finished lambda=\",lambda))\n    \n    return(list( Subnet_size = num_gene_selected, Best_Scores = best_score, Subnet = optimal_subnet, GA_obj = GA_result))\n}",
    "created" : 1469283555204.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2469068852",
    "id" : "BC5F7F11",
    "lastKnownWriteTime" : 1469293895,
    "path" : "D:/Code/Bioconductor/PPINet/R/GA_search_connected.R",
    "project_path" : "R/GA_search_connected.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}